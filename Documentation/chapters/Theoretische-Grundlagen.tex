\chapter{Theoretische Grundlagen}

\section{Machine Learning}
\label{chap:t_ml}
Teilbereich künstliche Intelligenz (Künstliche Intelligenz ist Maschine, die
menschliche Tätigkeiten nachmacht) Maschine = Computer -> Computerprogramm
(Algorithmus) Machine Learning ist Überbegriff -> Computerprogramme, die eine
Mustererkennung entwickeln. Durch Analysieren von Daten. KI lernt Vorhersagen

Beispiel Zahlenerkennung: Beispiel für Künstliche Intelligenz Bild einer
handschriftlichen Zahl wird Programm übergeben (Input) Das Programm bestimmt, um
welche Zahl es sich handelt. Programm gibt Zahl aus

Künstliche Intelligenz weil das Erkennen von Zahlen menschlich ist.

Unterschied machine Learning: KI lernt von Grund auf, Zahlen zu Erkennen Anfang
wird allermeistens Falsch sein

KI lernt durch die Analyse von Daten. -> Trainingsdaten. Dabei ist bekannt, was
die richtige Lösung zu den gegebenen Daten ist. So erfährt die KI, wenn sie
falsch liegt. Programm kann sich bezogen auf Erfahrung selbst anpassen.
Anpassungen möglichst so, dass Vorhersagen in Zukunft besser sind.

Nachdem KI mit Trainingsdaten verbessert wurde, sollte diese auch für neue Daten
möglichst genaue Vorhersagen machen.

Nächste Frage: Wie trifft KI entscheidungen, und wie kann sie sich selbst
Anpassen? -> Antwort Neuronale Netze


\subsection*{künstliche neuronale Netze}

Grundbaustein eines neuronalen Netzes sind Neuronen, (modelle eines biologischen
Neurons) mehrere Eingaben, eine Ausgabe. Eingaben sind verschieden wichtig (sind
gewichtet) Wenn Eingaben zusammen einen gewissen Grenzwert überschreiten,
"Feuert" das Neuron. 1 anstelle von 0 wenn es nicht feuert (vereinfachte
Erklärung eines Sigmoid-Neuron)

Es gibt Neuronen mit Eingaben in KI. Diese haben verbindungen zu weiteren
Neuronen in der nächsten Ebene (versteckte Ebene). Die Letzte Ebene des Netzes
hat die Ausgabe Neuronen (mit MNIST Beispiel erklären. Im Beispiel sind es 10
Neuronen, wobei jedes Neuron eine andere Zahl von 0-9 darstellt. Diese Neuronen
haben keine Ausgabe mehr, die für das neuronale Netz relevant ist. Die
Entscheidung basiert in diesem Fall lediglich darauf, welches der 10
Ausgabeneurenen den höchsten Wert enthält. Die Zahl, die dieses Neuron
repräsentiert, wird dann als die Entscheidung des Neuronalen Netzes angesehen).
mehr als eine versteckte Ebene ermöglicht schwierigere Entscheidungen -> Deep
learning

Der Lernprozess findet durch eine anpassung von Einzelnen Gewichten der
Eingaben, wenn die KI eine falsche Entscheidung trifft. Dadurch soll die
Entscheidung so angepasst werden, dass sie im nächsten Fall besser ausfällt

Neuronale Netze sind in Ebenen aufgeteilt. Eingabe Ebene, Ausgabe Ebene. Und
Ebenen dazwischen. Versteckte Ebenen. Sobald es mehr als eine Ebene an
versteckten Ebene gibt, nennt man es Deep learning.

\subsection*{Arten von Machine Learning}

Es gibt 3 Arten von Machine Learning Algorithmen: supervised, unsupervised,
reinforcement learning. Nachfolgend werden supervised und unsupervised learqing
kurz erklärt. Reinforcement learning im nächsten Kapitel, weil für Methode
hinter Arbeit wichtig

Erkennung von Handschriftlichen Daten ist supervised learning -> Typisch sind
Trainingsdaten, bei denen die richtige Lösung bekannt ist. Algorithmus wird also
auf Vorhersagen trainiert, die vorher als richtig angesehen wurden.
Gewissermassen also Algorithmus in Freiheit seiner Lösung eingeschränkt und
passt sich den Vorstellungen von demjenigen an, der die Daten präpariert hat
(Also die seiner Meinung nach richtigen Lösungen) an. Wird also überwacht.

unsupervised learning ist das Gegenteil. Wird nicht auf vorgegebene Lösungen
trainiert. Stattdessen soll Algorithmus selbstständig Muster in Daten erkennen.
Es wird also im voraus nicht definiert, was der Algorithmus lernen soll.
Angewendet für Gliederungen und Klassifikationen in Datensätzen, wo Menschen den
Überblick verlieren würden. Ausserdem, weil im voraus komplett unklar ist, wie
der Algorithmus die Daten verarbeitet, können neue Muster erkannt werden.
Muster, die von Menschen bisher übersehen wurden 


\section{Reinforcement Learning}
\label{chap:t_rl}

Reinforcement Learning bedeutet vereinfacht Lernen durch Interaktion mit der
Umgebung. (Sutten, Barto)  Genauer lernt ein Machine Learning Algorithmus durch
die Interaktion mit einer Umgebung, wie er sich in dieser Verhalten soll.

Reinforcement Learning Algorithmen führen also die Umgebung ein. In Supervised
Learning und Unsupervised Learning werden Daten bereitgestellt, aus denen der
Machine Learning Algorithmus "lernt". Bei einer Umgebung sind diese Daten
allerdings im Voraus nicht bekannt. Das kommt daher, dass eine Umgebung häufig
zu viele verschiedene Zustände einnehmen kann, als dass diese im Vorraus erfasst
werden könnten. Der Machine Learning Algorithmus kann trotzdem aus der Umgebung
lernen, indem dieser selbt als Element der Umgebung angesehen wird und so mit
ihr interagieren kann.

Die echte Welt kann ebenfalls als eine Umgebung angesehen werden. Der Mensch
wäre in diesem Fall der Machine learning Algorithmus. Der Mensch erlernt zum
Beispiel das Laufen, indem er mit der Welt interagiert. Eine Interaktion wäre
hier zum Beispiel das Hinfallen. Dadurch erlernt der Mensch das Verhalten der
Schwerkraft, welches zu diesem Fall geführt hat. Der Mensch lernt dieses
Verhalten durch eigene Erfahrungen, ohne dass ihm vorher bereits Daten über die
Welt gezeigt wurden. 

Reinforcement Learning Algorithmen stellen dieses Lernverhalten nach. So
verwenden Roboter, die das Laufen lernen sollen häufig diesen Ansatz. Die
Umgebung ist für den Reinforcement Learning Algorithmus im Roboter tatsächlich
die echte Welt. Bei der Umgebung kann es sich aber auch um eine
Computersimulation handeln.

\subsection*{Aufbau und Funktionsweise}

Dieser Abschnitt umfasst eine genauere Erklärung eines Reinforcement Learning
Algorithmus (Deep Q-Learning) unter der Verwendung der korrekten Fachbegriffe.

Ein Reinforcement Learning Algorithmus umfasst eine Umgebung und einen Agenten.
Der Agent ist dasjenige Element in der Umgebung, welches mit dieser interagiert
und daraus lernt. Der Agent umfasst ein Neuronales Netz. Die Eingabe in dieses
Netz ist die \textbf{Beobachtung} der Umgebung, also diejenigen aktuellen Daten
aus der Umgebung, die für den Agenten relevant sind. Die Ausgabe des Netzes
entspricht einer gewissen Anzahl Neuronen, die alle einen bestimmten Wert (den
\textbf{Q-Wert}) haben, der jeweils von der Eingabe abhängt. Jedes Neuron
repräsentiert eine Aktion, wobei jenes Neuron mit dem höchsten Q-Wert als die
`beste' Aktion angesehen wird. Der Agent kann somit nur eine festgelegte Anzahl
verschiedener Aktionen ausführen, die durch die Anzahl der Neuronen der Ausgabe
definiert ist. Der Agent führt in den meisten Fällen diejenige Aktion aus, die
als die beste definiert ist. Mit einer kleinen Wahrscheinlichkeit führt er
allerdings eine zufällige Aktion aus. Die Hoffnung dahinter ist, dass sich die
zufällige Aktion schlussendlich als noch besser herausstellt 

Nachdem der Agent eine Aktion ausführt, wird der Einfluss dieser Aktion auf die
Umgebung gemessen. Dabei bestimmt eine \textbf{Reward-funciton}, ob die Aktion
positiv oder negativ auf die Umgebung wirkt. Das wird durch eine Zahl
ausgedrückt. Umso grösser die Zahl, desto positiver ist der Effekt auf die
Umgebung und umgekehrt. Diese Zahl wird Belohnung oder \textbf{Reward} genannt.
Der Q-Wert der ausgeführten Aktion wird schliesslich bezogen auf den Reward
angepasst (Durch die Bellman Gleichung). Ein Kleinerer Reward führt zu einem
kleineren Q-Wert für die Aktion, wodurch diese in Zukunft weniger wahrscheinlich
gewählt wird. Umgekehrt macht ein grösserer Reward die Aktion, die diesen
ausgelöst hat, in Zukunft wahrscheinlicher. Nach der Anpassung des Q-Werts wird
das Neuronale Netz auf diese neue Ausgabe trainiert. Die Gewichte im Neuronalen
Netz werden also so angepasst, dass die Ausgabe einer ähnliche Eingabe in
Zukunft näher an den neu angepassten Q-Werten ist als an den alten.

\section{Verwandte Arbeiten und Themen}
\label{chap:t_verwandt}
Es gibt verschiedene Ansätze, um ein Computerprogramm die menschliche Tätigkeit
des Nachzeichnens verrichten zu lassen. Diese Ansätze werden in verschiedenen
wissenschaftlichen Arbeiten verfolgt. Ein häufiger Ansatz ist "Stroke-Based
Rendering", wobei Bilder durch das Platzieren von Elementen wie Strichen
gezeichnet werden. Beispiele für Arbeiten, die diesen Ansatz verwenden sind\dots
Stroke-Based Rendering unterscheidet sich von menschlichem Zeichnen dadurch,
dass kein Stift geführt wird. Stattdessen können die Elemente zu jedem Zeitpunkt
an einer willkürlichen Position auf der Zeichenfläche platziert werden.

Andere Ansätze simulieren die Führung eines Stiftes. Das Computerprogramm kann
also nicht zu jedem Zeitpunkt an jedem Ort Zeichnen. Stattdessen ist es an eine
Position (einen Stift) gebunden, welche mit einer gewissen Geschwindigkeit
bewegt werden kann. Das ist eine Einschränkung, die auch auf menschliches
Zeichnen mit einem Stift zutrifft. Ein Beipiel für ein Computerprogramm, das
diese Art des Zeichnens Nachahmt ist Doodle-SDQ von ...


\subsection*{Doodle-SDQ}
Doodle-SDQ ist ein Programm, das durch Deep Q Learning erlernt hat, Strichbilder
aus dem Google Quick-Draw Datenset nachzuzeichnen. Das Programm stammt aus der
Arbeit `Learning to Doodle with Deep Q-Networks and Demonstration Strokes' von
Tao Zhou et Al. aus dem Jahr 2018. Wie der Titel beschreibt basiert das Programm
auf dem Deep Q-Learning Algorithmus (siehe oben). `Demonstration Strokes' ist
ein weiteres verfolgtes Konzept in der Arbeit. Dieses gehört allerdings nicht
zum Bereich von Reinforcement learning sonders ist vereinfacht gesagt eine
Methode zur Optimierung des Algorithmus. Die Folgende Erklärung bezieht sich
daher nur auf den Deep Q-Learning Algorithmus.

Das Quick-Draw Datenset von Google beinhaltet Bilder von verschiedenen,
menschlichen Strichzeichnungen. Das Programm versucht, diese Bilder
nachzuzeichnen. Dazu werden die Bilder zuerst auf eine einheitliche Grösse von
84x84 Pixeln komprimiert. Der Agent kann sich auf dieser Fläche bewegen und
Zeichnen. Es handelt sich bei dieser Zeichenfläche um die Umgebung des Agenten
Der Agent kann sich mit einer Aktion auf einen beliebigen Pixel in einem 11x11
Feld, in dessen Zentrum er ist, bewegen. Dabei kann der Agent entweder zwischen
seiner alten und seiner neuen Position Zeichnen oder nicht. Der Agent kann somit
insgesamt 2x11x11 Aktionen ausführen. Diese Anzahl Aktionen entspricht
gleichzeitig der Anzahl Neuronen in der Ausgabe des neuronalen Netzes. Die
Eingabe in das Netz, also die Beobachtung der Umgebung wird in zwei Teile
gegliedert: Ein globaler Teil (global channel) und ein lokaler Teil (local
channel). Der Globale Teil umfasst das vorgegebene Bild (die Vorlage), das bis
anhin gezeichnete Bild, die aktuelle Position des Agenten und die Angabe, ob der
Agent gerade am Zeichnen ist oder nicht. Der Lokale Teil umfasst nur noch das
11x11 Feld vom vorgegebenen und dem bis anhin gezeichneten Bild, das sich direkt
um den Agenten befindet. Diese erneute Eingabe des kleineren Feldes in das Netz
ist notwendig, weil die unmittelbare Umgebung des Agenten für die Entscheidung
der nächsten Aktion sehr relevant ist. Der Reward wird durch die Anzahl der neu
übereinstimmenden Pixeln zwischen der Vorlage und dem bis anhin
gezeichneten Bild bestimmt. 











\section{Git und GitHub}
\label{chap:t_git}

\section{Git und GitHub}
\label{chap:git_github}
Git und Github sind weit verbreitete Hilfsmittel für Entwickler. Bei Git handelt
es sich um ein Programm, während Github ein Service ist, um Projekte, welche mit
Git verwaltet werden, öffentlich zugänglich zu machen. GitHub bringt zusätzlich
viele weitere nützliche Features, welche die Zusam\hyp{}menarbeit erleichtern. Die
genaue Funktion und das Zusammenspiel dieser beiden Hilfsmittel wird nachfolgend
erläutert.

\subsection*{Git}
Git ist ein Programm, welches Veränderungen im Code eines Projektes erkennt und
zwischen Versionen speichert. Dieses Konzept nennt sich Version Control. Es
wurde 2005 von Linus Torvald für die Entwicklung des Linux Kernels entwickelt.
Der Unterschied zwischen Git und anderer Version Control Software ist, dass
jeder, der am Code arbeiten will, den gesamten Code, auch Source Code genannt,
braucht. Dadurch ist das System dezen\hyp{}tralisierter.
\cite{noauthor_git_2021}

Wer Git benutzen will, erstellt ein Git Projekt (Repository) in einem Ordner
seiner Wahl. Sobald der Code verändert wird, sei es auch nur ein Buchstabe in
einer Zeile mehr, wird Git diese Veränderung finden und anzeigen. Diese
Veränderung kann man speichern, in dem man einen Commit macht. Falls ein Problem
entsteht, welches nicht mehr so einfach rückgängig zu machen ist, oder nicht
klar ist, was einen Bug auslöst, kann zu einem früheren Commit zurückgesprungen
werden. Man kann sich dann den Unterschied zwischen den Commits anschauen oder
vom alten weiterarbeiten. Wenn man an einem früheren Commit weiterarbeiten will
oder man sich wünscht, weiterzuarbeiten, ohne die Funktionstüchtigkeit des
Projektes zu gefährden, kann ein Branch erstellt werden. In einem Branch können
Veränderungen vorgenommen werden, ohne den Main (auch genannt Master, siehe
\autoref{fig:githist}), also das ursprüngliche Projekt zu verändern. Wenn die
Arbeit an einem Branch fertig und funktionstüchtig ist, kann dieser wieder mit dem
Main Branch zusammengefügt werden, wodurch alle Änderungen übernommen werden. 

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{img/GitBranches.png}
    \caption{Git History mit einem Branch \cite{fireship_git_2020}}
    \label{fig:githist}
\end{figure}

Die folgende Branch-Struktur (siehe \autoref{fig:branch}) hat sich bei Entwicklern bewährt und wird heute
empfohlen: Zuoberst ist der Main Branch. Auf diesem Branch sollte das fertige Projekt
sein, welches möglichst stabil ist, also ohne Bugs läuft. Davon weggehend hat man
einen Develop Branch. Auf diesem ist eine noch instabilere Version des
Projektes, die aber weiter fortgeschritten in der Entwicklung ist. Von diesem
weggehend gibt es die Feature Branches. Dort wird gesondert an einem Feature für
das Projekt gearbeitet. Wenn das Feature fertig entwickelt wurde, wird es mit
dem develop branch zusammengeführt. Ist das Projekt bereit für eine neue
Release Version, kann es in den Main Branch zurückgeführt werden. Oft gibt
es weiter Stadien zwischen dem Develop und Main Branch. Zum Teil sind
gewisse Änderungen für die Vorbereitung vom Release nötig. Diese werden im
Release Branch gemacht. Wenn ein Bug erst im Release gefunden wird, löst man
diesen häufig in einem neuen, so genannten Hotfix Branch.
\cite{noauthor_successful_nodate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{img/Branching Modell.png}
    \caption{Das Branching Modell \cite{noauthor_successful_nodate}}
    \label{fig:branch}
\end{figure}

Git wird vor allem als Console Interface, also mit Befehlen, verwendet, die in
eine Konsole eingegeben werden. Es gibt auch grafische Programme, die die
Bedienung von Git veranschaulichen. Häufig geben diese Programme
zusätzlich eine Visualisierung der gesamten Source Code History, wodurch man
sich einen Überblick über die Versionen verschaffen kann. 

Git ist nicht die einzige Version Control Software. Andere Beispiele wären:
Azure DevOps Server, Helix Core, AWS CodeCommit, Subversion, Plastic SCM, etc. 
\cite{noauthor_git_nodate-1}

\subsection*{GitHub}
Es wird häufig gedacht, dass Git und GitHub dasselbe sei, was allerdings nicht
richtig ist. Git ist die Version Control Software, die das Verwalten der
verschiedenen Versionen ermöglicht. GitHub ist ein Service, der es ermöglicht,
die von Git erstellten Repositories als Cloud Lösung bereit zu stellen. Durch
diesen Cloud Service von GitHub ist es möglich, gemeinsam an den verschiedenen
Versionen des Source Codes zu arbeiten. GitHub stellt dafür auch eine Webseite
zur Verfügung, um die Projekte zu verwalten. Dabei ist Git für die Bearbeitung
der Repositiories zuständig, während GitHub die Repositories den anderen
Entwicklern bereitstellt.
\cite{noauthor_github_2021} 

``GitHub wurde von Chris Wanstrath, PJ Hyett, Scott Chacon und Tom Preston-Werner
[...] entwickelt und im Februar 2008 gestartet'' \cite{noauthor_github_2021}.
2018 wurde das Unternehmen von Microsoft gekauft. GitHub ist heute eine der
grössten Plattformen für Open Source Projekte und das Zusammenarbeiten an
Software. Projekte können ohne Umstände für Leute auf der ganzen Welt zugänglich
gemacht werden. Wenn Entwickler an einem öffentlichen Projekt auf Github
Interesse finden, können sie selbst daran weiterarbeiten. 
\cite{noauthor_github_2021}

Um die Codequalität trotz einer grossen Menge an alleinstehenden Ent\hyp{}wicklern zu
gewährleisten, gibt es auf GitHub einige Tools, die das Zusamm\hyp{}enarbeiten, das
Kommunizieren und das Bewerten von Code vereinfachen. Einige dieser Tools werden
nachfolgend vorgestellt.

Jedes Repository hat einen eigenen Issue Tracker. Damit kann man Probleme am
Projekt äussern. Diese werden entweder im dazugehörigen Chat gelöst, oder können
von einem Entwickler übernommen werden. Das Problem wird in letzterem Fall in
einem separaten Branch gelöst. Sobald der Entwickler das Problem gelöst hat,
kann er eine Pull Request stellen. Damit fragt er den Rest der Entwickler an, ob
seine gelöste Version in den nächsthöheren Branch geführt werden darf. Auch
diese Pull Requests können von jeder Person angeschaut werden, aber eine
Beurteilung kann nur ein Teammitglied von dem Repository durchführen. GitHub
zeigt, durch die Zusammenarbeit mit Git, alle gespeicherten Veränderungen
zwischen den beiden Branches, die zusammengeführt werden sollen. So kann der
Beurteiler jede Zeile anschauen und Änderungen anfragen. Auch GitHub kann den
Code automatisch be\hyp{}urteilen, sofern die GitHub Actions eingerichtet wurden. Das
sind Test Runner, welche Tests aus dem Konzept des Test Driven Developments
automatisch ausführen. Dadurch kann überprüft werden, ob die Integrität der
Software mit diesen Änderungen beschädigt wurde. Ausserdem gibt es Add-Ons, die
automatisch überprüfen, ob in den Veränderungen die Konventionen der jeweiligen
Sprache eingehalten wurde.

Ein weiteres Feature von GitHub ist das integrierte Task Board, welches nach dem
Kanban Prinzip benutzt werden kann. Ausserdem gibt es ein Wiki, wo
ausführlichere Dokumentationen zum Projekt beinhaltet sind. Eine Kurzfassung,
wie die Software genutzt wird, findet sich meist auf der Startseite vom
Repository in der sogenannten `README.md' Datei. Wenn das Wiki nicht für die
Dokumentation ausreicht, gibt es auch die Möglichkeit, GitHub Pages zu
verwenden. Dadurch werden Webseiten für die Repositories zur Verfügung gestellt.
Weitere kleine Features von Github, wie ein Forum, eine AI, welche beim
Programmieren hilft, und einen Onlinewebeditor, befinden sich noch in der
Testphase.

GitHub ist grundsätzlich mit vielen Features kostenlos zugänglich. Das gilt vor
allem für die öffentlich Repositories. Man kann auch Repositories erstellen,
welche nicht öffentlich zugänglich sind, aber solange man keine GitHub Pro hat,
sind diese eingeschränkt. Ausserdem ist die Grösse der Dateien auf 100MB
limitiert. Wenn die eigenen Dateien grösser werden, muss man den Git Large File
Storage (LFS) aktivieren, welcher 1GB Speicher erlaubt zusätzlich ist die Anzahl
Minuten des Test Runners bei den GitHub Actions nur zu einem gewissen Grad
gratis. Mit GitHub Pro werden diese Limits etwas erhöht. Wird dieses Limit auch
überschritten, können zusätzliche Minuten oder Speicher erworben werden.

Für Schüler und Studenten hat GitHub ein eigenes GitHub Students Pack, bei dem
man sich verifizieren kann und einige Software oder Abos auf eine gewisse Zeit
gratis bekommt. Dazu zählt auch GitHub Pro.

GitHub ist nicht die einzige Plattform, welche das Hosten von Git Repositories
erlaubt. Es gibt weitere Konkurrenten, wie: GitLab, Bitbucket, GitBucket, etc.
\cite{noauthor_top_2021}



